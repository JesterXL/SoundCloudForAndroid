package com.jxl.soundcloud.rl.models{	import com.jxl.soundcloud.events.AuthorizeEvent;	import com.jxl.soundcloud.services.AuthorizeSoundCloudAPIService;		import flash.media.StageWebView;	import flash.net.SharedObject;		import org.iotashan.oauth.OAuthToken;	import org.robotlegs.mvcs.Actor;		public class AuthorizationModel extends Actor	{		[Inject]		public var authService:AuthorizeSoundCloudAPIService;				private static const TOKEN_SO:String = "token";				public function AuthorizationModel()		{			super();		}				public function authorize(webView:StageWebView):void		{			eventMap.mapListener(authService, AuthorizeEvent.SOUND_CLOUD_AUTHORIZED, onAuthorized, AuthorizeEvent);			eventMap.mapListener(authService, AuthorizeEvent.ACCESS_TOKEN_ERROR, onAuthorizedError, AuthorizeEvent);			eventMap.mapListener(authService, AuthorizeEvent.REQUEST_TOKEN_ERROR, onAuthorizedError, AuthorizeEvent);						authService.authorize(webView, readToken());		}				public function getAccessToken(code:String):void		{			eventMap.mapListener(authService, AuthorizeEvent.SOUND_CLOUD_AUTHORIZED, onAuthorized, AuthorizeEvent);			eventMap.mapListener(authService, AuthorizeEvent.ACCESS_TOKEN_ERROR, onAuthorizedError, AuthorizeEvent);			eventMap.mapListener(authService, AuthorizeEvent.REQUEST_TOKEN_ERROR, onAuthorizedError, AuthorizeEvent);						authService.getAccessToken(code);		}				public function clearToken():void		{			var so:SharedObject = SharedObject.getLocal(TOKEN_SO);			so.data.key = null;			so.data.secret = null;			so.clear();		}				public function abort():void		{			clearToken();			authService.abort();		}				private function onAuthorizedError(event:AuthorizeEvent):void		{			dispatch(event);		}				private function onAuthorized(event:AuthorizeEvent):void		{			saveToken(event.token.key, event.token.secret);			dispatch(event);		}								private function readToken():OAuthToken		{			var so:SharedObject = SharedObject.getLocal(TOKEN_SO);			if(so.data.key && so.data.secret)			{				return new OAuthToken(so.data.key, so.data.secret);			}			else			{				return null;			}		}				private function saveToken(key:String, secret:String):void		{			var so:SharedObject 	= SharedObject.getLocal(TOKEN_SO);			so.data.key 			= key;			so.data.secret 			= secret;			so.flush();		}	}}